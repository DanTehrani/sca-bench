{
  "findings": [
    {
      "title": "[M-01] Supply function doesn’t account for market maxDeposit when providing assets to it",
      "description": "Some vaults that the Silo vault deposits into have their own supply caps (do not confuse with `config[market].cap`), which may prevent `_supplyERC4626` from fully depositing user-provided assets. If these caps are not accounted for, the deposit function may revert instead of distributing assets across multiple vaults.",
      "contractName": "SiloVault",
      "proofOfConcept": "Consider a scenario where there are two vaults available for deposits:\n\n- Vault 1 has a supply cap of 10,000 assets and currently holds 5,000, meaning `vault1.maxDeposit` is 10,000 - 5,000 = 5,000.\n- Vault 2 is in the same condition.\n\nIn total, 10,000 assets of deposit space are available. However, if a user tries to deposit 10,000 assets through the Silo vault, `_supplyERC4626` is called:\n\n```grvsc-code\n    function _supplyERC4626(uint256 _assets) internal virtual {\n        for (uint256 i; i < supplyQueue.length; ++i) {\n            IERC4626 market = supplyQueue[i];\n\n            uint256 supplyCap = config[market].cap;\n            if (supplyCap == 0) continue;\n\n            // Update internal balance for market to include interest if any.\n            // `supplyAssets` needs to be rounded up for `toSupply` to be rounded down.\n            uint256 supplyAssets = _updateInternalBalanceForMarket(market);\n\n            uint256 toSupply = UtilsLib.min(UtilsLib.zeroFloorSub(supplyCap, supplyAssets), _assets);\n\n            if (toSupply != 0) {\n                uint256 newBalance = balanceTracker[market] + toSupply;\n                // As `_supplyBalance` reads the balance directly from the market,\n                // we have additional check to ensure that the market did not report wrong supply.\n                if (newBalance <= supplyCap) {\n                    // Using try/catch to skip markets that revert.\n>>                  try market.deposit(toSupply, address(this)) {\n                        _assets -= toSupply;\n                        balanceTracker[market] = newBalance;\n                    } catch {}\n                }\n            }\n\n            if (_assets == 0) return;\n        }\n    }\n```\n\nThe function will first attempt to deposit 10,000 assets into Vault 1, but since `vault1.maxDeposit` < 10,000, the transaction will revert. The same issue occurs with Vault 2, causing the entire deposit operation to fail—even though sufficient space exists across both vaults."
    },
    {
      "title": "[M-02] SiloVault will incorrectly accrue rewards during user transfer/transferFrom actions due to unsynced totalSupply()",
      "description": "SiloVault’s totalSupply() accrueFees from interests (delta totalAssets). Such fee accrual is updated through _accrueFee() which mints an additional share to the fee reciever.\n\nWe see that when claiming rewards directly through `claimRewards()` the accrued extra share is updated first before _claimRewards().\n\nThe vulnerability is when `_claimRewards()` is invoked atomically through hooks ( _update), the `_accrueFee()` will be missed in the user’s transfer/transferFrom call. In this case, an incorrect totalSupply() will be used for fee accrual, leading to incorrect fee accrual.\n\nImpacts: incorrect and inconsistent reward accrual due to unsynced `totalSupply()`.",
      "contractName": "SiloVault",
      "proofOfConcept": "We see in direct `claimRewards` flow. `totalSupply()` will be updated in `_accrueFee()`.\n\n```grvsc-code\n    function claimRewards() public virtual {\n        _nonReentrantOn();\n\n|>      _updateLastTotalAssets(_accrueFee());\n        _claimRewards();\n\n        _nonReentrantOff();\n    }\n```\n\n```grvsc-code\n    function _accrueFee() internal virtual returns (uint256 newTotalAssets) {\n        uint256 feeShares;\n        (feeShares, newTotalAssets) = _accruedFeeShares();\n        //@audit this will increase totalSupply()\n|>      if (feeShares != 0) _mint(feeRecipient, feeShares);\n\n        emit EventsLib.AccrueInterest(newTotalAssets, feeShares);\n    }\n```\n\nHowever, the vulnerable flow is transfer/transferFrom -> _update(), where `_accrueFee()` is missed.\n\n```grvsc-code\n    function _update(address _from, address _to, uint256 _value) internal virtual override {\n        // on deposit, claim must be first action, new user should not get reward\n\n        // on withdraw, claim must be first action, user that is leaving should get rewards\n        // immediate deposit-withdraw operation will not abused it, because before deposit all rewards will be claimed, so on withdraw on the same block no additional rewards will be generated.\n\n        // transfer shares is basically withdraw->deposit, so claiming rewards should be done before any state changes\n|>      _claimRewards(); //@audit rewards is claimed without first updating totalSupply(). transfer/transferFrom flow is vulnerable.\n\n        super._update(_from, _to, _value);\n\n        if (_value == 0) return;\n\n        _afterTokenTransfer(_from, _to, _value);\n    }\n```\n\nWe know transfer/transferFrom flow is vulnerable because unlike deposit/withdraw which calls `_accrueFee()` first, transfer/transferFrom will directly call `_update()` without updating totalSupply. This causes an incorrect/inconsistent reward accrual."
    },
    {
      "title": "[M-03] SiloVault.sol :: Markets with assets that revert on zero approvals cannot be removed.",
      "description": "To remove a market from the vault, the supply `cap` must be set to 0. However, when this happens, the market’s allowance to use tokens from the vault is also reset to 0. The issue arises because some tokens revert when attempting to approve a 0 value, preventing these markets from being removed from the vault.",
      "contractName": "SiloVault",
      "proofOfConcept": "`submitMarketRemoval()` is implemented as follows.\n\n```grvsc-code\nfunction submitMarketRemoval(IERC4626 _market) external virtual onlyCuratorRole {\n        if (config[_market].removableAt != 0) revert ErrorsLib.AlreadyPending();\n@>      if (config[_market].cap != 0) revert ErrorsLib.NonZeroCap();\n        if (!config[_market].enabled) revert ErrorsLib.MarketNotEnabled(_market);\n        if (pendingCap[_market].validAt != 0) revert ErrorsLib.PendingCap(_market);\n\n        // Safe \"unchecked\" cast because timelock <= MAX_TIMELOCK.\n        config[_market].removableAt = uint64(block.timestamp + timelock);\n\n        emit EventsLib.SubmitMarketRemoval(_msgSender(), _market);\n    }\n```\n\nAs you can see, removing a market requires setting the `cap` to 0 (the same applies to `updateWithdrawQueue()`.). This is done by calling `submitCap()` with `_newSupplyCap` set to 0.\n\n```grvsc-code\nfunction submitCap(IERC4626 _market, uint256 _newSupplyCap) external virtual onlyCuratorRole {\n        if (_market.asset() != asset()) revert ErrorsLib.InconsistentAsset(_market);\n        if (pendingCap[_market].validAt != 0) revert ErrorsLib.AlreadyPending();\n        if (config[_market].removableAt != 0) revert ErrorsLib.PendingRemoval();\n        uint256 supplyCap = config[_market].cap;\n        if (_newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();\n\n        if (_newSupplyCap < supplyCap) {\n            _setCap(_market, SafeCast.toUint184(_newSupplyCap));\n        } else {\n            pendingCap[_market].update(SafeCast.toUint184(_newSupplyCap), timelock);\n\n            emit EventsLib.SubmitCap(_msgSender(), _market, _newSupplyCap);\n        }\n    }\n```\n\nIn this case, the execution will enter the `if` section, which calls `_setCap()`, which invokes `setCap()` from the `SiloVaultActionsLib`.\n\n```grvsc-code\nfunction setCap(\n        IERC4626 _market,\n        uint184 _supplyCap,\n        address _asset,\n        mapping(IERC4626 => MarketConfig) storage _config,\n        mapping(IERC4626 => PendingUint192) storage _pendingCap,\n        IERC4626[] storage _withdrawQueue\n    ) external returns (bool updateTotalAssets) {\n        MarketConfig storage marketConfig = _config[_market];\n        uint256 approveValue;\n\n        if (_supplyCap > 0) {\n            if (!marketConfig.enabled) {\n                _withdrawQueue.push(_market);\n\n                if (_withdrawQueue.length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();\n\n                marketConfig.enabled = true;\n\n                // Take into account assets of the new market without applying a fee.\n                updateTotalAssets = true;\n\n                emit EventsLib.SetWithdrawQueue(msg.sender, _withdrawQueue);\n            }\n\n            marketConfig.removableAt = 0;\n            // one time approval, so market can pull any amount of tokens from SiloVault in a future\n            approveValue = type(uint256).max;\n        }\n\n        marketConfig.cap = _supplyCap;\n@>      IERC20(_asset).forceApprove(address(_market), approveValue);\n\n        emit EventsLib.SetCap(msg.sender, _market, _supplyCap);\n\n        delete _pendingCap[_market];\n    }\n```\n\nAs you can see, we do not enter the `if` block because `_supplyCap = 0`, which results in `approveValue = 0` (default value). This is expected since we want to clear the market’s allowance. However, some assets (such as [BNB](https://github.com/d-xo/weird-erc20?tab=readme-ov-file#revert-on-large-approvals--transfers)) revert when the approval value is set to `0`, causing `forceApprove()` to fail.\n\nAs a result, the cap cannot be set to `0`, preventing the market from being removed. Furthermore, if the vault relies on markets with such assets and they cannot be removed, new ones cannot be added due to the `MAX_QUEUE_LENGTH` restriction."
    },
    {
      "title": "[M-04] Lack of slippage and deadline protection in deposit(), withdraw() and redeem()",
      "description": "1. When users [deposit](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L569) funds, those assets are allocated to one or more underlying ERC4626 markets according to the supply queue.\n2. When withdrawing or redeeming, assets are pulled from the underlying markets according to the withdraw queue and shares burned.\n\nNone of these actions allow the user to specify any acceptable slippage or deadline.\n\n- The vault interacts with multiple ERC4626 vaults. Share price in these underlying vaults can change between transaction submission and execution.\n- During deposit, the protocol might need to distribute assets across multiple markets based on their caps. This multi-step process could expose users to price changes.\n- During withdrawals or redemptions, the protocol attempts to pull assets from markets in a specific order. If a market has insufficient liquidity, the next market is tried, which might have different share pricing.\n- The [_accrueFee()](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L942) function is called during both deposit and withdrawal, which can change the conversion rate between shares and assets.\n\nAdditionally, there’s a risk of transactions getting stuck in the mempool during periods of network congestion and hence deadline protection is needed.",
      "contractName": "SiloVault",
      "proofOfConcept": "User may recieve less than expected shares or assets due to unfavourable price movement or execution delays."
    },
    {
      "title": "[M-05] Incorrect reward distribution due to feeShares minting order",
      "description": "The current implementation distributes rewards _before_ minting fee shares, resulting in the fee recipient receiving shares but no rewards for the corresponding interest accrual period. This creates an inconsistency where the existing share owners receive higher than deserved portion of rewards.",
      "contractName": "SiloVault",
      "proofOfConcept": "Let’s assume Bob is the sole shareholder. What’s happening right now is:\n- Bob deposits at `t` and receives `100%` shares (for simplicity let’s ignore, for now, the `DECIMALS_OFFSET` strategy deployed by the protocol to thwart the first-depositor attack).\n- At some time, `t2`, we see that yield & reward has accrued.\n- Someone calls [claimRewards()](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L495) which first internally calls `_updateLastTotalAssets(_accrueFee())` and then `_claimRewards()`:\n\n```grvsc-code\n495:              function claimRewards() public virtual {\n496:                  _nonReentrantOn();\n497:\n498:@--->             _updateLastTotalAssets(_accrueFee());\n499:@--->             _claimRewards();\n500:\n501:                  _nonReentrantOff();\n502:              }\n```\n\n- [_accrueFee() internally calls _mint()](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L946) if `feeShares != 0`.\n\n```grvsc-code\n942:              function _accrueFee() internal virtual returns (uint256 newTotalAssets) {\n943:                  uint256 feeShares;\n944:                  (feeShares, newTotalAssets) = _accruedFeeShares();\n945:\n946:@--->             if (feeShares != 0) _mint(feeRecipient, feeShares);\n947:\n948:                  emit EventsLib.AccrueInterest(newTotalAssets, feeShares);\n949:              }\n```\n\n- Note that `_accruedFeeShares()` on L944 is a **_retrospective way_** to calculate the `feeShares` which should correspond to the `feeAssets` amount applied on the accumulated interest. This is done because the total assets have already grown between `t` and `t2`. This is evident from the `newTotalAssets - feeAssets` term inside [_accruedFeeShares()](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L951-L969) and also the comments on L960-961:\n\n```grvsc-code\n951:              /// @dev Computes and returns the fee shares (`feeShares`) to mint and the new vault's total assets\n952:              /// (`newTotalAssets`).\n953:              function _accruedFeeShares() internal view virtual returns (uint256 feeShares, uint256 newTotalAssets) {\n954:                  newTotalAssets = totalAssets();\n955:\n956:                  uint256 totalInterest = UtilsLib.zeroFloorSub(newTotalAssets, lastTotalAssets);\n957:                  if (totalInterest != 0 && fee != 0) {\n958:                      // It is acknowledged that `feeAssets` may be rounded down to 0 if `totalInterest * fee < WAD`.\n959:                      uint256 feeAssets = totalInterest.mulDiv(fee, WAD);\n960:@--->                 // The fee assets is subtracted from the total assets in this calculation to compensate for the fact\n961:@--->                 // that total assets is already increased by the total interest (including the fee assets).\n962:                      feeShares = _convertToSharesWithTotals(\n963:                          feeAssets,\n964:                          totalSupply(),\n965:@--->                     newTotalAssets - feeAssets,\n966:                          Math.Rounding.Floor\n967:                      );\n968:                  }\n969:              }\n```\n\n- What this means is that the fee recipient is going to be minted the `feeShares` currently because they have a rightful claim to the `feeAssets` which started to accrue right from timestamp `t`.\n\nWith that in mind, let’s see the remaining steps -\n- On L946 `_accrueFee() --> _mint()` internally calls the [overridden _update()](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L985) function, which in turn calls `_claimRewards()` before `super._update()` actually mints these `feeShares` and increases `totalSupply()`. As the inline code comments explain, this is meant to be a safeguard and it is required so that rewards can be claimed before a new deposit/withdraw/transfer:\n\n```grvsc-code\n976:              function _update(address _from, address _to, uint256 _value) internal virtual override {\n977:                  // on deposit, claim must be first action, new user should not get reward\n978:\n979:                  // on withdraw, claim must be first action, user that is leaving should get rewards\n980:\n981:                  // immediate deposit-withdraw operation will not abused it, because before deposit all rewards will be\n982:                  // claimed, so on withdraw on the same block no additional rewards will be generated.\n983:\n984:                  // transfer shares is basically withdraw->deposit, so claiming rewards should be done before any state changes\n985:@--->             _claimRewards();\n986:\n987:                  super._update(_from, _to, _value);\n988:\n989:                  if (_value == 0) return;\n990:\n991:                  _afterTokenTransfer(_from, _to, _value);\n992:              }\n```\n\n- In this case however, what it means is that the **entire** reward is doled out to Bob since he possesses `100%` of shares because the `feeShares` are yet to be minted. By the time the control reaches the second call to `_claimRewards()` on [L499](https://github.com/code-423n4/2025-03-silo-finance/blob/main/silo-vaults/contracts/SiloVault.sol#L499) after minting of these shares, there are no more rewards left to be distributed to the fee recipient."
    },
    {
      "title": "[M-06] Deflation attack",
      "description": "The flow of assets between SiloVault and its markets favour the markets (per standard ERC4626 specifications). This means that SiloVault can lose assets compared to its total supply of shares. This deflates the share price. At low total asset levels, this can be exploited to deflate the share price until the shares per asset is close to overflowing.\n\nThis can be exploited to either simply brick the vault, or such that the attacker is the guaranteed sole holder and recipient of the incentive rewards.",
      "contractName": "SiloVault",
      "proofOfConcept": "The shares minted is calculated as `_assets.mulDiv(_newTotalSupply + 10 ** _decimalsOffset(), _newTotalAssets + 1, _rounding)`, where the [total assets](https://github.com/code-423n4/2025-03-silo-finance/blob/0409be5b85d7aabfbbe10de1de1890d4b862d2d5/silo-vaults/contracts/SiloVault.sol#L647-L652) is based on the redeemable value of all market shares held by SiloVault.\n\nFor example, the first depositor deposits 1 wei into SiloVault, which deposits this into a market, and mints `10 ** _decimalsOffset()` shares. The market, however, is likely to round this away and not return any share to SiloVault. On the next deposit into SiloVault, `totalAssets` is zero, but `10 ** _decimalsOffset()` shares were minted. Again depositing 1 wei mints `2 * 10 ** _decimalsOffset()`, without increasing `totalAssets`. Each repetition doubles the total supply.\n\nThe same would, of course, happen if `totalAssets` on deposit did increase to `1` but due to the market updating its price, this later became `0`.\n\nSuppose SiloVault were to instead mint shares according to the increase in `totalAssets`. Then no shares would be minted in the above example.\nSuppose then 10 wei are deposited into SiloVault, which deposits this into a market, in return, for 8 market shares (let’s say the market’s price is 1.13 assets/share). This is redeemable for 9 asset tokens, so SiloVault mints `9 * 10 ** _decimalsOffset()` shares. Now, redeeming `8 * 10 ** _decimalsOffset()` shares from SiloVault makes SiloVault withdraw 8 asset tokens from the market. Withdrawing 8 asset tokens burns not 7.08 but all 8 market shares, and SiloVault is now, just as above, left with zero totalAssets but a total supply of `1 * 10 ** _decimalsOffset()`."
    }
  ]
}